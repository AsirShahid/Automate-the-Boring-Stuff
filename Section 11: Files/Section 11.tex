% Created 2021-08-04 Wed 17:20
% Intended LaTeX compiler: pdflatex
\documentclass[11pt]{article}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{graphicx}
\usepackage{grffile}
\usepackage{longtable}
\usepackage{wrapfig}
\usepackage{rotating}
\usepackage[normalem]{ulem}
\usepackage{amsmath}
\usepackage{textcomp}
\usepackage{amssymb}
\usepackage{capt-of}
\usepackage{hyperref}
\author{Mohammed Asir Shahid}
\date{2021-08-04}
\title{Section 11\\\medskip
\large Files}
\hypersetup{
 pdfauthor={Mohammed Asir Shahid},
 pdftitle={Section 11},
 pdfkeywords={},
 pdfsubject={},
 pdfcreator={Emacs 27.2 (Org mode 9.5)}, 
 pdflang={English}}
\begin{document}

\maketitle
\tableofcontents


\section{Filenames and Absolute/Relative File Paths}
\label{sec:org4238179}

We'll learn about files, folders, and how Python can work with them.

If we want our data to persist after our program is finished, we need to save it to a file.

\subsection{Fileames and File Paths}
\label{sec:orgaffca4e}

Each of our files has 2 key properties. The file name and the file path.

\subsection{os module}
\label{sec:orgf004cef}

The os module contains numerous file path related functions that we can use.

\subsubsection{os.getcwd()}
\label{sec:org96eeb33}

Every program has a setting called the current working directory, this tells us the directory that we are currently in. We can use the getcwd() function in order to find our current working directory.

\begin{verbatim}

import os

print(os.getcwd())

\end{verbatim}

\begin{verbatim}
/home/mohammeds/Documents/Automate the Boring Stuff/Section 11: Files
\end{verbatim}

\subsubsection{os.chdir()}
\label{sec:orgc01deb3}

We can also change the current working directory using this chdir() function.

\begin{verbatim}

import os

print(os.getcwd())

os.chdir("/")

print(os.getcwd())

\end{verbatim}

\begin{verbatim}
/home/mohammeds/Documents/Automate the Boring Stuff/Section 11: Files
/
\end{verbatim}

\subsection{Absolute and Relative Paths}
\label{sec:orga5fe18a}

There are two kinds of file paths, relative and absolute. The absolute file path begins with the root directory and gives you the complete location of the file. A relative file path is relative to the current working directory.

\subsection{. and .. Folders}
\label{sec:org6c22e2b}

These are not real directories, but they can be used with relative paths. The single dot stands for this directory while two dots stands for the paret directory, the directory that your current working directory is in.

\subsection{os.path module}
\label{sec:org35802ed}
\subsubsection{os.path.join()}
\label{sec:org66a20ed}

This is a join function inside of a path module inside of an os module. It takes several string arguments and returns a string value of a path for the os that you are using.

\begin{verbatim}

import os
print(os.path.join("folder1","folder2","folder3","file.png"))

\end{verbatim}

\begin{verbatim}
folder1/folder2/folder3/file.png
\end{verbatim}

\subsubsection{os.path.abspath()}
\label{sec:org1d164d0}

The abspath() function will return the absolute path of the path that you pass it.

\begin{verbatim}

import os

print(os.path.abspath("Section 11.org"))


\end{verbatim}

\begin{verbatim}
/home/mohammeds/Documents/Automate the Boring Stuff/Section 11: Files/Section 11.org
\end{verbatim}

\subsubsection{os.path.isabs()}
\label{sec:org45e05b3}

The isabs() function is a way to determine if a given path is absolute.

\begin{verbatim}

import os

print(os.path.abspath("Section 11.org"))

print(os.path.isabs("Section 11.org"))

print(os.path.abspath("/home/mohammeds/Documents/Automate the Boring Stuff/Section 11: Files/Section 11.org"))

print(os.path.isabs("/home/mohammeds/Documents/Automate the Boring Stuff/Section 11: Files/Section 11.org"))

\end{verbatim}

\begin{verbatim}
/home/mohammeds/Documents/Automate the Boring Stuff/Section 11: Files/Section 11.org
False
/home/mohammeds/Documents/Automate the Boring Stuff/Section 11: Files/Section 11.org
True
\end{verbatim}

\subsubsection{os.path.relpath()}
\label{sec:org7ef7eec}

This function will give you the relative path between two paths. The first argument is the file/directory we want to get to and the second is the directory we are already in.



\begin{verbatim}

import os

print(os.path.relpath("Section 11.org", "/usr/bin"))

print(os.path.relpath("Section 11.org", "/home/mohammeds/"))


\end{verbatim}

\begin{verbatim}
../../home/mohammeds/Documents/Automate the Boring Stuff/Section 11: Files/Section 11.org
Documents/Automate the Boring Stuff/Section 11: Files/Section 11.org
\end{verbatim}

\subsubsection{os.path.dirname()}
\label{sec:org1162c6f}

This function pulls out just the directory part of the path.

\begin{verbatim}

import os

print(os.path.dirname("/home/mohammeds/Documents/Automate the Boring Stuff/Section 11: Files/Section 11.org"))

\end{verbatim}

\begin{verbatim}
/home/mohammeds/Documents/Automate the Boring Stuff/Section 11: Files
\end{verbatim}

\subsubsection{os.path.basename()}
\label{sec:org2f07529}

This function pulls out just the last part of the path. Either the filename or just the directory itself if there is no file in the path.

\begin{verbatim}

import os

print(os.path.basename("/home/mohammeds/Documents/Automate the Boring Stuff/Section 11: Files/Section 11.org"))

\end{verbatim}

\begin{verbatim}
Section 11.org
\end{verbatim}

\subsubsection{os.path.exists()}
\label{sec:org5f39acf}

This function can check and see if the path you are passing actually exists.

\begin{verbatim}

import os

print(os.path.exists("/home/mohammeds/Documents/Automate the Boring Stuff/Section 11: Files/Section 11.org"))

print(os.path.exists("/home/mohammeds/Fake File Path"))

\end{verbatim}

\begin{verbatim}
True
False
\end{verbatim}

\subsubsection{os.path.isfile()}
\label{sec:orgdb30002}

We can use this function to see if what we pass to it is a file or not.

\begin{verbatim}

import os

print(os.path.isfile("/home/mohammeds/Documents/Automate the Boring Stuff/Section 11: Files/Section 11.org"))

print(os.path.isfile("/home/mohammeds/Fake File Path"))

\end{verbatim}

\begin{verbatim}
True
False
\end{verbatim}

\subsubsection{os.path.isdir()}
\label{sec:orgf097937}

We can use this function to see if what we pass to it is a directory or not.

\begin{verbatim}

import os

print(os.path.isdir("/home/mohammeds/Documents/Automate the Boring Stuff/Section 11: Files/Section 11.org"))

print(os.path.isdir("/home/mohammeds/"))

\end{verbatim}

\begin{verbatim}
False
True
\end{verbatim}

\subsubsection{os.path.getsize()}
\label{sec:orgad0b03a}

This function gives us the size of the file in bytes.

\begin{verbatim}

import os

print(os.path.getsize("/home/mohammeds/Documents/Automate the Boring Stuff/Section 11: Files/Section 11.org"))

\end{verbatim}

\begin{verbatim}
16162
\end{verbatim}

\subsection{os.listdir()}
\label{sec:org532ebb1}

This function isn't in the path module. It can be passed a file path of a folder and then it'll return a list of strings of the filenames and folder names that it contains.

\begin{verbatim}

import os

print(os.listdir("/home/mohammeds/Documents"))

\end{verbatim}

\begin{verbatim}
['[Chapman and Hall_CRC the R Ser] Albert, Jim_ Baumer, Benjamin S._ Marchi, Max - Analyzing Baseball Data with R (2018, Chapman and Hall_CRC) - libgen.lc.pdf', 'bedrock-linux-0.7.20beta1-x86_64.sh', 'fstab.txt', 'Verify Payment.pdf', 'mission-369-advanced-regular-expressions-takeaways.pdf', 'userguide.pdf', 'Quidditch Through the Ages - J.K. Rowling.pdf', 'Resume', 'SmashCharacters.txt', 'LFS-BOOK-10.1.pdf', 'Linux From Scratch - Version 10.1 - LFS-BOOK-10.1.pdf', 'Oathbringer_ Book Three of the Stormlight Archive_B01NAWAH85.kfx', 'Andrew Ng Machine Learning Lectures', 'Hugo Websites', 'Data Scientist in Python DataQuest', 'mohammed-shahid-python-for-data-science-fundamentals.pdf', 'README.md', '.git', 'mkdir', 'Crypto Trading Bot', 'Machine Trading', 'The Home Depot - Order Confirmation.pdf', 'Online Return Center.pdf', 'LeetCode', 'Kaggle', 'Coursera', 'Data Analyst in R DataQuest', 'edX', 'org-basics.org', 'happybday.org', 'org', 'letter.org', 'AB_NYC_2019.csv', 'cse351_hw1_fazli_faraz_110018236.ipynb', '.ipynb_checkpoints', 'mariaradio.org', '.auctex-auto', 'mariaradio.tex', 'mariaradio.pdf', 'mariaradio.md', 'mariaradio.html', 'Order Confirmation _ Law School Admission Council.pdf', 'marialetter.org', 'Automate the Boring Stuff', 'TEKgence Application Form.xlsx', '.dir-locals.el']
\end{verbatim}

\subsection{Example Code: Finding the total size of all files in a folder.}
\label{sec:org9423fad}

\begin{verbatim}

import os

totalSize=0

for file in os.listdir("/home/mohammeds/Documents"):
    if not os.path.isfile(os.path.join("/home/mohammeds/Documents", file)):
        continue
    totalSize+=os.path.getsize(os.path.join("/home/mohammeds/Documents", file))

print(totalSize)

\end{verbatim}

\begin{verbatim}
382371482
\end{verbatim}

\subsection{os.makedirs()}
\label{sec:orgbf438c0}

This function can create directories for you.

\begin{verbatim}

import os

print(os.getcwd())

print(os.listdir())

os.makedirs("TestDir")

print(os.listdir())

\end{verbatim}

\section{Reading and Writing Plaintext Files}
\label{sec:orga83f5c1}

We can start writing strings to files that we create in order to save information. We can then read this data with Python.

\subsection{Plaintext and Binary Files}
\label{sec:orga524ad2}

Plaintext files only contain basic text characters and don't include information about color or font. Often times they have .txt extensions. Python scripts are also plain text files, except they use the .py file extension.

They can be opened with text editors such as Emacs.

Binary files are all other types of files. PDF, JPG, PNG, etc. When you open these with a text editor, it will be impossible to understand.

\subsection{Reading or Writing Files in Python}
\label{sec:org8ceea4e}

There are three main steps for reading and writing files in Python.

\subsubsection{The open() Function}
\label{sec:org2f85978}

This function opens files.

\begin{verbatim}

open("hello.txt")

\end{verbatim}

\subsubsection{Read Mode}
\label{sec:org541cdde}

The open() function opens the file in read mode. This only lets you read the data, it does not let you modify it.

\subsubsection{The read() method}
\label{sec:orgf42615a}

This method lets you read the opened file.

\subsubsection{The close() method}
\label{sec:org4c45975}

This method closes the opened file. If you want to continue accessing it, you should save it to a variable.

\begin{verbatim}

helloFile=open("hello.txt")


content=helloFile.read()

print(content)

helloFile.close()

\end{verbatim}

\begin{verbatim}
Hello!
How are you?How are you?How are you?How are you?How are you?
\end{verbatim}

\subsubsection{The readlines() Method}
\label{sec:org8fb95be}

This method returns all of the lines as strings within a list.

\begin{verbatim}

helloFile=open("hello.txt")
content=helloFile.readlines()

print(content)

\end{verbatim}

\begin{verbatim}
['Hello!\n', 'How are you?How are you?How are you?How are you?How are you?']
\end{verbatim}

\subsubsection{Write mode}
\label{sec:orgfaa81c9}

In order to write to a file, it needs to be opened in write or append mode. This can overwrite existing files. For write mode, you can pass in a ``w'' argument to the open() function.

\begin{verbatim}

helloFile=open("hello2.txt","w")
helloFile.write("Hello!!!!")

\end{verbatim}

\subsubsection{Append mode}
\label{sec:orgbdecb30}

In order to write to a file, it needs to be opened in write or append mode. This can overwrite existing files. For append mode, you can pass in a ``a'' argument to the open() function.

\begin{verbatim}

helloFile=open("hello.txt", "a")
helloFile.write("How are you?")

\end{verbatim}

\subsubsection{Example}
\label{sec:orge44edd1}

\begin{verbatim}


baconFile=open("bacon.txt", "w")

baconFile.write("Bacon is not a vegetable")
baconFile.close()

baconFile=open("bacon.txt")

print(baconFile.read())

\end{verbatim}

\begin{verbatim}
Bacon is not a vegetable
\end{verbatim}

\subsection{The shelve Module}
\label{sec:orgade6e10}

Writing and reading text files is a good way to store single long strings, but if we want to save more complex data structures like lists and dictionaries, then we can save Python programs to binary shelve files.

\subsubsection{The shelve.open() Method}
\label{sec:orgdae3e4b}

This method can open shelve files.

\begin{verbatim}

import shelve

shelfFile=shelve.open("mydata")
shelfFile["cats"]=["Zophie","Pooka","Simon","Fat-tail","Cleo"]
shelfFile.close()

shelfFile=shelve.open("mydata")
print(shelfFile["cats"])

\end{verbatim}

\begin{verbatim}
['Zophie', 'Pooka', 'Simon', 'Fat-tail', 'Cleo']
\end{verbatim}


The benefit of using the shelve module is that you can store lists, dictionaries, and non text data and then reopen them in the future.

\subsubsection{The keys() and values() Shelf Methods}
\label{sec:orgc8b9057}

Shelf file objects are very similar to dictionaries in the sense that they have keys and values.

\begin{verbatim}

import shelve

shelfFile=shelve.open("mydata")

print(shelfFile.keys())
print(shelfFile.values())


print(list(shelfFile.keys()))
print(list(shelfFile.values()))

shelfFile.close()
\end{verbatim}

\begin{verbatim}
KeysView(<shelve.DbfilenameShelf object at 0x7f13ee031130>)
ValuesView(<shelve.DbfilenameShelf object at 0x7f13ee031130>)
['cats']
[['Zophie', 'Pooka', 'Simon', 'Fat-tail', 'Cleo']]
\end{verbatim}

\section{Copying and Moving Files and Folders}
\label{sec:orga43f392}

We can also organize files on our drive using Python.

\subsection{Shell Utilities Module}
\label{sec:org22139b5}

This module has functions that let us copy, rename, and delete files in Python programs.

\subsubsection{shutil.copy() Function}
\label{sec:org732d881}

This function lets us copy files in Python. We can either copy and leave the filename or copy and give a new file name.

\begin{verbatim}

import shutil,os

shutil.copy("hello2.txt", "TestDir")

shutil.copy("hello2.txt", "TestDir/newhello2.txt")

print(os.listdir("TestDir"))

\end{verbatim}

\begin{verbatim}
['hello2.txt', 'newhello2.txt']
\end{verbatim}

\subsubsection{shutil.copytree() Function}
\label{sec:org3fbc4ba}

The copy function works for single files, but what if we want to copy an entire folder? Then we can use the copytree function.


\begin{verbatim}

import shutil,os

shutil.copytree("TestDir","TestDirBackup")

\end{verbatim}

\begin{verbatim}

import shutil,os

print(os.listdir("TestDirBackup"))

\end{verbatim}

\begin{verbatim}
['hello2.txt', 'newhello2.txt']
\end{verbatim}

\subsubsection{shutil.move() function}
\label{sec:org42ad127}

This can be used for moving and renaming files. If you want to rename a file, you can move it to the same directory using the move() function and then change the filename.

\begin{verbatim}

import shutil,os

shutil.move("TestDirBackup/newhello2.txt", ".")

print(os.listdir("TestDirBackup"))

\end{verbatim}

\section{Deleting Files}
\label{sec:org0614349}

There are three functions that we can use for deleting files.

\subsection{Deleting Functions}
\label{sec:org5087f44}

\subsubsection{os.unlink() (Deletes a single file.)}
\label{sec:org10e4ef6}

\begin{verbatim}

import os

os.unlink("hello2.txt")


\end{verbatim}

\begin{verbatim}

import os

print(os.listdir())

\end{verbatim}

\begin{verbatim}
['.gitkeep', 'Section 11.org', '.auctex-auto', 'Section 11.tex', 'Section 11.pdf', 'Section 11.md', 'udemy-automate-boring-python-lesson-30.mp4', 'udemy-automate-boring-python-lesson-31.mp4', 'udemy-automate-boring-python-lesson-32.mp4', 'udemy-automate-boring-python-lesson-33.mp4', 'udemy-automate-boring-python-lesson-34.mp4', 'TestDir', 'hello.txt', 'mydata', 'newhello2.txt', 'bacon.txt', 'TestDirBackup']
\end{verbatim}

\subsubsection{os.rmdir() (Delete an empty folder)}
\label{sec:org9e9da03}

This function only removes directories that are completely empty. If the directory you try to delete has data, Python will return an error.

\subsubsection{shutil.rmtree() (Deletes a folder and its entire contents)}
\label{sec:org42f33d1}

This is the delete analog of the copytree() function.

\begin{verbatim}

import os,shutil

shutil.rmtree("TestDirBackup")

print(os.listdir())

\end{verbatim}

\begin{verbatim}
['.gitkeep', 'Section 11.org', '.auctex-auto', 'Section 11.tex', 'Section 11.pdf', 'Section 11.md', 'udemy-automate-boring-python-lesson-30.mp4', 'udemy-automate-boring-python-lesson-31.mp4', 'udemy-automate-boring-python-lesson-32.mp4', 'udemy-automate-boring-python-lesson-33.mp4', 'udemy-automate-boring-python-lesson-34.mp4', 'TestDir', 'hello.txt', 'mydata', 'newhello2.txt', 'bacon.txt']
\end{verbatim}

\subsection{Dry Run}
\label{sec:orgcd6c895}

These deleting functions can be dangerous, so in order to make sure nothing goes wrong, we should do a dry run when using them.

Here we would comment out any line containing deleting functions and then instead printing out the files that we were trying to delete. This can help us make sure that we are not deleting the wrong thing.

\begin{verbatim}

import os,shutil

os.chdir("/home/mohammeds/Documents")

for filename in os.listdir():
    if filename.endswith(".rxt"):
#        os.unlink(filename)
        print(filename)

\end{verbatim}

\subsection{The send2trash Module}
\label{sec:org0a7c439}

These deleting functions are still dangerous, even when doing a dry run since they will be deleted permanently. Instead, we can use the send2trash module's functions which sends the files to the recycling bin.

We need to install it using pip.

\begin{verbatim}
pip install send2trash
\end{verbatim}

\begin{verbatim}

import send2trash

send2trash.send2trash("bacon.txt")

\end{verbatim}
\end{document}
