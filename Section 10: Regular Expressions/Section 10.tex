% Created 2021-08-03 Tue 22:58
% Intended LaTeX compiler: pdflatex
\documentclass[11pt]{article}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{graphicx}
\usepackage{grffile}
\usepackage{longtable}
\usepackage{wrapfig}
\usepackage{rotating}
\usepackage[normalem]{ulem}
\usepackage{amsmath}
\usepackage{textcomp}
\usepackage{amssymb}
\usepackage{capt-of}
\usepackage{hyperref}
\author{Mohammed Asir Shahid}
\date{2021-08-03}
\title{Section 10\\\medskip
\large Regular Expressions}
\hypersetup{
 pdfauthor={Mohammed Asir Shahid},
 pdftitle={Section 10},
 pdfkeywords={},
 pdfsubject={},
 pdfcreator={Emacs 27.2 (Org mode 9.5)}, 
 pdflang={English}}
\begin{document}

\maketitle
\tableofcontents


\section{Regular Expression Basics}
\label{sec:org18088ce}

In this lesson, we will be working with pattern matching and regular expressions. Regular expressions allow you to specify a pattern of text to search for.

An example of a text pattern would be a phone number. 415-555-0000. In the US, this is the standard way of writing up phone numbers. If we had that same number but without the hyphens, we would not recognize it as a phone number.

\begin{verbatim}
def isPhoneNumber(text):
    if len(text) != 12:
        return False
    for i in range(0, 3):
        if not text[i].isdecimal():
            return False
    if text[3] != '-':
        return False
    for i in range(4, 7):
        if not text[i].isdecimal():
            return False
    if text[7] != '-':
        return False
    for i in range(8, 12):
        if not text[i].isdecimal():
            return False
    return True

print(isPhoneNumber("415-555-1234"))
print(isPhoneNumber("My Phone Number"))

\end{verbatim}

\begin{verbatim}
True
False
\end{verbatim}


That's a lot of code for a relatively simple task. If we want to find phone numbers in large strings, we'd need to write some more code.

\begin{verbatim}
def isPhoneNumber(text):
    if len(text) != 12:
        return False
    for i in range(0, 3):
        if not text[i].isdecimal():
            return False
    if text[3] != '-':
        return False
    for i in range(4, 7):
        if not text[i].isdecimal():
            return False
    if text[7] != '-':
        return False
    for i in range(8, 12):
        if not text[i].isdecimal():
            return False
    return True

print(isPhoneNumber("415-555-1234"))
print(isPhoneNumber("My Phone Number"))

message="Call me at 415-555-1011 tomorrow, or 415-555-9999 for my office line"

foundNuumber=False

for i in range(len(message)):
    chunk=message[i:i+12]
    if isPhoneNumber(chunk) == True:
        print("Phone number found")
        foundNumber=True
if not foundNumber:
    print("Could not find any phone numbers")

\end{verbatim}

\begin{verbatim}
True
False
Phone number found
Phone number found
\end{verbatim}

\subsection{The re Module}
\label{sec:org43b0d28}

We can write the previous code much faster using regular expressions.

\begin{verbatim}

import re

message="Call me at 415-555-1011 tomorrow, or 415-555-9999 for my office line"

phoneNumRegex=re.compile(r"\d\d\d-\d\d\d-\d\d\d\d")

mo=phoneNumRegex.search(message)

print(type(mo))
print(mo.group())

print(phoneNumRegex.findall(message))


\end{verbatim}

\begin{verbatim}
<class 're.Match'>
415-555-1011
['415-555-1011', '415-555-9999']
\end{verbatim}

\section{Regex Groups and the Pipe Character}
\label{sec:org5ef2a2f}

We can try some more of Python's more powerful pattern matching capabilities.

Let's say we want to seperate the area code from a phone number.


\begin{verbatim}

import re

phoneNumRegex = re.compile(r"\d\d\d-\d\d\d-\d\d\d\d")
mo=phoneNumRegex.search("My number is 415-555-4242")
print(mo.group())


\end{verbatim}

\begin{verbatim}
415-555-4242
\end{verbatim}

\subsection{Groups}
\label{sec:orgcb0f0c4}

Let's say we only want the phone number or only the phone number portion of the number. We can do this sing parentheses to mark out groups in the string.

\begin{verbatim}

import re

phoneNumRegex = re.compile(r"(\d\d\d)-(\d\d\d-\d\d\d\d)")
mo=phoneNumRegex.search("My number is 415-555-4242")
print(mo.group())

print(mo.group(1))
print(mo.group(2))

\end{verbatim}

\begin{verbatim}
415-555-4242
415
555-4242
\end{verbatim}


The parentheses there can be useful syntax when we want to find specific parts of something. However, what can we do when we want to find literal parentheses? We would escape them using parentheses.

\begin{verbatim}

import re

phoneNumRegex = re.compile(r"\(\d\d\d\) \d\d\d-\d\d\d\d")
mo=phoneNumRegex.search("My number is (415) 555-4242")
print(mo.group())

\end{verbatim}

\begin{verbatim}
(415) 555-4242
\end{verbatim}

\subsection{Pipe Character |}
\label{sec:org87a5ba6}

Pipes can be used to match one of several patterns as part of the regular expression.

Let's say we wanted to match any of the strings ``Batman'', ``Batmobile'', ``Batcopter'', or ``Batbat''


\begin{verbatim}

import re

batRegex = re.compile(r"Bat(man|mobile|copter|bat)")
mo=batRegex.search("Batmobile lost a wheel.")
print(mo.group())
print(mo.group(1))

\end{verbatim}

\begin{verbatim}
Batmobile
mobile
\end{verbatim}


If the search method can't find the regular expression pattern, it will return None. In that case, we can risk running into errors.

\section{Repetition in Regex Patterns and Greedy/Nongreedy Matching}
\label{sec:orga108cd9}

How can we match a certain number of repetitions of a group? For example, one or more repitions, between 7 and 10 repitions, etc.

\subsection{? (zero or one)}
\label{sec:org8d81bae}
This says match the preceding group either 0 or 1 times.

\begin{verbatim}

import re

#batRegex=re.compile(r"Batman|Batwoman")
batRegex=re.compile(r"Bat(wo)?man")

mo=batRegex.search("The Adventures of Batman")
print(mo.group())

mo=batRegex.search("The Adventures of Batwoman")
print(mo.group())

mo=batRegex.search("The Adventures of Batwowoman")
print(mo)

\end{verbatim}

\begin{verbatim}
Batman
Batwoman
None
\end{verbatim}


Using our earlier phone number example, we can make a regular expression that looks for phone numbers that do or do not have an area code. With our previous code, if we did not have an area code then the regex would not find the phone number.


\begin{verbatim}

import re

phoneRegex=re.compile(r"\d\d\d-\d\d\d-\d\d\d\d")

mo = phoneRegex.search("My phone number is 415-555-1234")
print(mo.group())

mo = phoneRegex.search("My phone number is 555-1234")
print(mo)

phoneRegex=re.compile(r"(\d\d\d-)?\d\d\d-\d\d\d\d")

mo = phoneRegex.search("My phone number is 415-555-1234")
print(mo.group())

mo = phoneRegex.search("My phone number is 555-1234")
print(mo.group())

\end{verbatim}

\begin{verbatim}
415-555-1234
None
415-555-1234
555-1234
\end{verbatim}


If we need to match a question mark as part of the expression, we can simply escape it by doing $\backslash$?.

\subsection{* (zero or more)}
\label{sec:orga0d3206}

The asterisk means match 0 or more times.


\begin{verbatim}

import re
batRegex=re.compile(r"Bat(wo)*man")

mo=batRegex.search("The Adventures of Batman")
print(mo.group())

mo=batRegex.search("The Adventures of Batwoman")
print(mo.group())

mo=batRegex.search("The Adventures of Batwowowoman")
print(mo.group())

\end{verbatim}

\begin{verbatim}
Batman
Batwoman
Batwowowoman
\end{verbatim}


If you need to match an * that appears in the pattern, you can escape it by doing $\backslash$*.

\subsection{+ (one or more)}
\label{sec:org8f64082}

Unlike the star, the group preceding a + must appear in the pattern.

\begin{verbatim}

import re
batRegex=re.compile(r"Bat(wo)+man")

mo=batRegex.search("The Adventures of Batman")
print(mo)

mo=batRegex.search("The Adventures of Batwoman")
print(mo.group())

mo=batRegex.search("The Adventures of Batwowowoman")
print(mo.group())

\end{verbatim}

\begin{verbatim}
None
Batwoman
Batwowowoman
\end{verbatim}


If you need to match a + that appears in the pattern, you can escape it by doing $\backslash$+.

\subsection{Escaping ?, *, and +}
\label{sec:orgfcbc2d1}


\begin{verbatim}

import re
regex = re.compile(r"\+\*\?")

mo=regex.search("I learned about +*? regex syntax")
print(mo.group())

\end{verbatim}

\begin{verbatim}
+*?
\end{verbatim}


We could also put the above +*? into a group and then putting a + after it to say that the group needs to appear at least once.

\begin{verbatim}

import re
regex = re.compile(r"(\+\*\?)+")

mo=regex.search("I learned about +*?+*?+*? regex syntax")
print(mo.group())

\end{verbatim}

\begin{verbatim}
+*?+*?+*?
\end{verbatim}

\subsection{\{x\} (exactly x)}
\label{sec:orgc851627}

This can be used if you wanted to match a specific number of repetitions of a group.


\begin{verbatim}

import re

haRegex=re.compile(r"(Ha){3}")
mo=haRegex.search("He said \"HaHaHa\"")
print(mo.group())

\end{verbatim}

\begin{verbatim}
HaHaHa
\end{verbatim}


While the above is a simple example, we could do it for many other, more complex examples.

\begin{verbatim}

import re

phoneRegex=re.compile(r"((\d\d\d-)?\d\d\d-\d\d\d\d(,)?){3}")
mo=phoneRegex.search("My numbers are 415-555-1234,555-4242,212-555-0000")
print(mo.group())

\end{verbatim}

\begin{verbatim}
415-555-1234,555-4242,212-555-0000
\end{verbatim}

\subsection{\{x,y\} (at least x, at most y)}
\label{sec:org75fc770}


\begin{verbatim}

import re
haRegex=re.compile(r"(Ha){3,5}")
mo=haRegex.search("He said \"HaHaHa\"")
print(mo.group())

mo=haRegex.search("He said \"HaHaHaHaHa\"")
print(mo.group())

mo=haRegex.search("He said \"HaHaHaHaHaHa\"")
print(mo)

\end{verbatim}

\begin{verbatim}
HaHaHa
HaHaHaHaHa
<re.Match object; span=(9, 19), match='HaHaHaHaHa'>
\end{verbatim}


We can also have no y value which would have no maximum and be unbounded, x or more.

\begin{verbatim}

import re

digitRegex=re.compile(r"(\d){3,5}")
mo=digitRegex.search("1234567890")
print(mo.group())

\end{verbatim}

\begin{verbatim}
12345
\end{verbatim}


As we can see above, there was a match of the first 5 digits even though the first 3 also would have sufficed. By default, Python regular expressions do greedy matches. This means that it tries to match the longest possible string that matches the pattern.

In order to do a nongreedy match, we can specify a question mark following the curly braces. Then it matches the first, shortest pattern.

\begin{verbatim}

import re

digitRegex=re.compile(r"(\d){3,5}?")
mo=digitRegex.search("1234567890")
print(mo.group())

\end{verbatim}

\begin{verbatim}
123
\end{verbatim}
\end{document}
