% Created 2021-07-31 Sat 12:43
% Intended LaTeX compiler: pdflatex
\documentclass[11pt]{article}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{graphicx}
\usepackage{grffile}
\usepackage{longtable}
\usepackage{wrapfig}
\usepackage{rotating}
\usepackage[normalem]{ulem}
\usepackage{amsmath}
\usepackage{textcomp}
\usepackage{amssymb}
\usepackage{capt-of}
\usepackage{hyperref}
\author{Mohammed Asir Shahid}
\date{2021-07-30}
\title{Section 3\\\medskip
\large Functions}
\hypersetup{
 pdfauthor={Mohammed Asir Shahid},
 pdftitle={Section 3},
 pdfkeywords={},
 pdfsubject={},
 pdfcreator={Emacs 27.2 (Org mode 9.5)}, 
 pdflang={English}}
\begin{document}

\maketitle
\tableofcontents


\section{Pythons Built-In Functions}
\label{sec:orgd324a15}

Python comes with many built in functions such as print, input, and len which we have already used. Python also comes with Modules known as the Standard Library. For example, we have the Math module containing mathematics functions, the random module containing random number functions, etc. In order to use functions from these modules, we need to import them as follows:

\begin{verbatim}

import random

print(random.randint(1,10))

\end{verbatim}

\begin{verbatim}
5
\end{verbatim}


The above randint function gives us a random number between the given integers. We need to preface the randint function by ``random'' since it is inside of the random module. It is not a built-in function, so Python will not find it without first calling the random module. Python's standard library has many such modules that can be imported via the import statement.

We can also import statements in a different way ``from random import *'' which removes the need to put in ``random'' before calling the function. However, this can decrease readibility as you do not know which module the function comes from.

\begin{verbatim}

from random import *

print(randint(1,10))

\end{verbatim}

\begin{verbatim}
7
\end{verbatim}


Sometimes you want to terminate a program early. There is a function for this in the ``sys'' module. The ``sys.exit'' function.


\begin{verbatim}

import sys

print("Hello")

sys.exit()

print("Goodbye")

\end{verbatim}

\begin{verbatim}
Hello
\end{verbatim}


As we can see above, the ``Goodbye'' string was not printed. This is due to the fact that we used the exit function and terminated the program early.


While Python comes with several modules in the standard library, we can also install new modules using the pip program.

\begin{verbatim}
pip install pyperclip
\end{verbatim}


The pyperclip module contains 2 functions, the copy and paste functions which can be used to copy and paste text.

\begin{verbatim}

import pyperclip

pyperclip.copy("Hello world!")
print(pyperclip.paste())


\end{verbatim}

\begin{verbatim}
Hello world!
\end{verbatim}

\section{Writing Your Own Functions}
\label{sec:org7a5b1e1}

A function is like a mini program inside of a program containing code that runs when the function is called.


\begin{verbatim}

def hello():
    print("Howdy!")
    print("Howdy!!!")
    print("Hello there.")

hello()
hello()
hello()

\end{verbatim}

\begin{verbatim}
Howdy!
Howdy!!!
Hello there.
Howdy!
Howdy!!!
Hello there.
Howdy!
Howdy!!!
Hello there.
\end{verbatim}


When a function is defined using the ``def'' statement, the code inside of it is not executed. The code inside the function is only executed when the function is called.

One of the benefits of functions is that it lets you avoid duplicating code. Duplication can be an issue because when you find a bug in the code, you need to make sure you fix it everywhere. With functions, you can just fix the function itself.

Our functions can also contain arguments that our function can use, for example the argument given in a ``print'' or ``len'' function.




\begin{verbatim}

def hello(name):
    print("Hello " + name)

hello("Alice")
hello("Bob")

\end{verbatim}

\begin{verbatim}
Hello Alice
Hello Bob
\end{verbatim}


Above when the ``hello'' function is called, the argument is passed into the function and used as the name variable.


\begin{verbatim}

def plusOne(number):
    return number+1


newNumber=plusOne(5)

print(newNumber)

\end{verbatim}

\begin{verbatim}
6
\end{verbatim}



What does the print function return?

The function returns a special value of a data type ``None''. It represents a lack of a data type.


\begin{verbatim}

spam=print()

print(type(spam))


\end{verbatim}

\begin{verbatim}

<class 'NoneType'>
\end{verbatim}


We can take away from this the fact that every function call has some sort of return value, including the print function. When a function does not have a return statement, the return value defaults to ``None'', as in the print function.


Some functions have keyword arguments. These can be optional arguments, for example the print function adds a new line after you call the function. However, this can be changed as seen below. We can also choose what separates the separating character between the arguments.


\begin{verbatim}

print("Hello")
print("World")


print("Hello", end="")
print("World")


print("cat", "dog", "mouse")


print("cat", "dog", "mouse", sep="ABC")

\end{verbatim}

\begin{verbatim}
Hello
World
HelloWorld
cat dog mouse
catABCdogABCmouse
\end{verbatim}

\section{Global and Local Scopes}
\label{sec:org96d6251}

Variables inside of a function can have the same name as variables inside of a function. This is due to the fact that some variables and parameters have a local scope and others have a global scope. Variables that are assigned inside of a function exist inside of the function's local scope while variables that are assigned outside of functions exist in the program's global scope which means they can be accessed from anywhere in the program. Any given line in the program is either in the global scope or inside of a local scope.

Scopes can be thought of containers for variables. All variables existing in the global scope are global variables while variables existing in a local scope are local variables.

A global scope for global variables is created when the program starts and is destroyed when the program ends while a local scope for local variables is created when the function is called and ends when the function returns.

There are a few reasons why local and global scopes matter.

\begin{enumerate}
\item Code in a global scope can't use local variable.

Let's look at the following example:
\end{enumerate}

\begin{verbatim}

def spam():
    eggs=99

spam()
print(eggs)

\end{verbatim}

This looks like it should work, however it returns an error saying that eggs is not defined.

When we call the spam function, it creates the local scope. However, the eggs variables does not print. This is because after the spam function runs and returns, the local scope is destroyed. Thus we can't use the local variable in our global scope.


\begin{enumerate}
\item Code in a local scope can use global variables.
\end{enumerate}


\begin{verbatim}

def spam():
    print(eggs)

eggs=42
    
spam()

\end{verbatim}

\begin{verbatim}
42
\end{verbatim}


As we can see above, first the spam function is assigned, then we define the eggs variable in the global scope, then the spam function is called. Now since Python does not see any local variables named eggs, it will check and see if there are any global variables named eggs, it will use that and print it out.

This eggs variable here is a global variable that is being read from a local scope. Python distinguishes based on where the variable is assigned.


\begin{verbatim}

def spam():
    eggs="Hello"
    print(eggs)

eggs=42

spam()

\end{verbatim}

\begin{verbatim}
Hello
\end{verbatim}


Above we can see that Python will prioritize local variables.

What if we want to change the global variable from inside of the local scope? We can do the following:

\begin{verbatim}

def spam():
    global eggs
    eggs="Hello"
    print(eggs)

eggs=42

spam()
print(eggs)

\end{verbatim}

\begin{verbatim}
Hello
Hello
\end{verbatim}


\begin{enumerate}
\item Code in one function's local scope can't use variables in another local scope.
\end{enumerate}

\begin{verbatim}

def spam():
    eggs=99
    bacon()
    print(eggs)

def bacon():
    ham=101
    eggs=0

spam()

\end{verbatim}

\begin{verbatim}
99
\end{verbatim}


The above code prints out 99, which is the value of the eggs variable inside of the spam function.

When bacon is called in the spam function, we know that the eggs variable inside of the bacon function is different than the eggs variable inside of the spam function. When the bacon function runs, it creates the local scope, assigns values to the ham and eggs variables, and then returns which destroys the local scope. Then the spam function continues and prints out eggs with a value of 99.


\begin{enumerate}
\item You can use the same name for variables given that they are in a different scope.

This is self explanatory.
\end{enumerate}


So why do we need to have local and global scopes in the first place? Why not just have everything as a global variables?

The benefit that local variables provide is that they separate code from the rest of the program. This helps with debugging. If something is wrong in the global scope because of a bad variable, you only need to check the global scope for issues. If something is wrong in a function due to a bad variable, you only need to check the local scope of the function.
\end{document}
